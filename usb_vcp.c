/*
 * buffer.c
 *
 *  Created on: 13.02.2023
 *      Author: Hartmut
 */
#include "usb_vcp.h"
#include "usbd_cdc_if.h"
#include "usbd_cdc.h"


#define RX_BUFFER_MAX_WRITE_INDEX (APP_RX_DATA_SIZE - CDC_DATA_FS_MAX_PACKET_SIZE)



 extern USBD_HandleTypeDef hUsbDeviceFS;

 //---------------------Private Function Declarations--------------------------------


 //---------------------Private Variable Declarations--------------------------------

 VCP_FIFO usb_rx_fifo;
 VCP_FIFO usb_tx_fifo;

 //----------------------------------------------------------------------------------
/// @brief  erzwingt einen USB disconnect indem die Datenleitung D+ auf Low gezogen wird
/// 		da die Specialfunction des Pins überschrieben wird, muss danach USB neu initialisiert werden
/// 		es muss also MX_USB_DEVICE_Init() erneut aufgerufen werden
///
 void usb_pre_init(void)  {

	if(usb_tx_fifo.data == 0){ // kein Buffer initialisiert
		GPIO_InitTypeDef GPIO_InitStruct = {0};
		GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
		GPIO_InitStruct.Pull = GPIO_PULLDOWN;
		GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;

#ifdef STM32F103xB
		GPIO_InitStruct.Pin = GPIO_PIN_12;
		HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
		HAL_GPIO_WritePin(GPIOA, GPIO_PIN_12, GPIO_PIN_RESET);
#endif
#ifdef STM32F446xx
		GPIO_InitStruct.Pin = GPIO_PIN_15;
		HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
		HAL_GPIO_WritePin(GPIOB, GPIO_PIN_15, GPIO_PIN_RESET);
#endif


		HAL_Delay(50);
	}
   }
//----------------------------------------------------------------------------------

 /// @brief
 ///  waits for the USB Enumeration  Event to happen
 /// this creates the USB buffers so fifo.data will change from 0 to the tx buffer address
inline void usb_is_init(void)
{

   while (usb_tx_fifo.data == 0);

}
//----------------------------------------------------------------------------------
/// @brief Update the write index for the next incoming packet
///
/// @param Len
/// @return new position for write pointer
uint8_t* usb_update_rx(uint32_t *Len){
// Update the write index for the next incoming packet
	  usb_rx_fifo.write += *Len;
	  // Is the new value too close to the end of the FIFO ?
	  if (usb_rx_fifo.write >= RX_BUFFER_MAX_WRITE_INDEX)
	  {
		// Solution : wrap-around (and save wr as lb)
		usb_rx_fifo.lb = usb_rx_fifo.write;
		usb_rx_fifo.write = 0;
	  }
	  return(usb_rx_fifo.data + usb_rx_fifo.write);
}
//----------------------------------------------------------------------------------

//----------------------------------------------------------------------------------
/// @brief links the circular buffers to allocated memory for RX and TX Buffers
///
/// @param UserTxBufferFS
/// @param UserRxBufferFS
void usb_vcp_init (uint8_t* UserTxBufferFS, uint8_t* UserRxBufferFS)
{
	  usb_tx_fifo.data = UserTxBufferFS;  // Use the buffer generated by Cube
	  usb_tx_fifo.write = 0;
	  usb_tx_fifo.read = 0;
	  usb_tx_fifo.lb = 0;
	  usb_rx_fifo.data = UserRxBufferFS;  // Use the buffer generated by Cube
	  usb_rx_fifo.write = 0;
	  usb_rx_fifo.read = 0;
	  usb_rx_fifo.lb = 0;
}

//----------------------------------------------------------------------------------

//----------------------------------------------------------------------------------
/// @brief Adds new data to the TX Buffer
/// 		All data is added to the tx-buffer as is. there is no formatting
///
/// @param buf Data to send
/// @param len	length of data in Byte
/// @return 0 success -1 Buffer full error
int usb_vcp_send (uint8_t* buf, uint16_t len)
{
  // Step 1 : calculate the occupied space in the Tx FIFO
  int cap = usb_tx_fifo.write - usb_tx_fifo.read;   // occupied capacity
  if (cap < 0)    // FIFO contents wrap around
    cap += APP_TX_DATA_SIZE;
  cap = APP_TX_DATA_SIZE - cap;      // available capacity
  // Step 2 : compare with argument
  if (cap < len)
    return -1;   // Not enough room to copy "buf" into the FIFO => error

  // Step 3 : does buf fit in the tail ?
  int tail = APP_TX_DATA_SIZE - usb_tx_fifo.write;
  if (tail >= len)
  {
    // Copy buf into the tail of the FIFO
    memcpy (&usb_tx_fifo.data[usb_tx_fifo.write], buf, len);
    // Update "wr" index
    usb_tx_fifo.write += len;
    // In case "len" == "tail", next write goes to the head
    if (usb_tx_fifo.write == APP_TX_DATA_SIZE)
      usb_tx_fifo.write = 0;
  }
  else
  {
    // Copy the head of "buf" to the tail of the FIFO
    memcpy (&usb_tx_fifo.data[usb_tx_fifo.write], buf, tail);
    // Copy the tail of "buf" to the head of the FIFO :
    memcpy (usb_tx_fifo.data, &buf[tail], len - tail);
    // Update the "wr" index
    usb_tx_fifo.write = len - tail;
  }
  return 0;  // successful completion
}
//----------------------------------------------------------------------------------

//----------------------------------------------------------------------------------
/// @brief reads len Bytes from receive buffer
///
/// @param buf  Target address
/// @param len requested Number of Bytes to read
/// @return number of Bytes actually read (con be shorter if rx_buffer contained less data)

int usb_vcp_recv (uint8_t* buf, uint16_t len)
{
  // Compute how much data is in the FIFO
  int cap = usb_rx_fifo.write - usb_rx_fifo.read;
  if (cap == 0)
    return 0;      // Empty FIFO, no data to read
  if (cap < 0)  // FIFO contents wrap around
    cap += usb_rx_fifo.lb;  // Notice the use of lb
  // Limit the FIFO read to the available data
  if (len > cap)
    len = cap;
  // Save len : it'll be the return value
  int retval = len;
  // Read the data
  while (len)
  {
    len--;
    *buf = usb_rx_fifo.data[usb_rx_fifo.read];
    buf++;
    usb_rx_fifo.read++;    // Update read index
    if (usb_rx_fifo.read == usb_rx_fifo.lb)  // Check for wrap-around
      usb_rx_fifo.read = 0;      // Follow wrap-around
  }
  return retval;
}
//----------------------------------------------------------------------------------

//----------------------------------------------------------------------------------
/// @brief
/// USB Service Routine this should be called regularly since this tests if Host is ready to receive new packets
/// and initializes transmission
void usb_vcp_service ()
{

  USBD_CDC_HandleTypeDef *hcdc = (USBD_CDC_HandleTypeDef*)hUsbDeviceFS.pClassData;
  // Test if the USB CDC is ready to transmit
  if (hcdc->TxState == 0)
  {
    // Update the FIFO to reflect the completion of the last transmission
    usb_tx_fifo.read = usb_tx_fifo.lb;
    // Compute how much data is in the FIFO
    int cap = usb_tx_fifo.write - usb_tx_fifo.read;
    if (cap != 0)  // The FIFO is empty : return immediately
    {
      if (cap < 0)  // The FIFO contents wrap-around
      {
        // Send only the tail of the FIFO
        USBD_CDC_SetTxBuffer(&hUsbDeviceFS, &usb_tx_fifo.data[usb_tx_fifo.read], APP_TX_DATA_SIZE - usb_tx_fifo.read);
        USBD_CDC_TransmitPacket(&hUsbDeviceFS);
        usb_tx_fifo.lb = 0;    // Lock the tail’s data
      }
      else  // No wrap-around : send the whole FIFO
      {
        USBD_CDC_SetTxBuffer(&hUsbDeviceFS, &usb_tx_fifo.data[usb_tx_fifo.read], cap);
        USBD_CDC_TransmitPacket(&hUsbDeviceFS);
        usb_tx_fifo.lb = usb_tx_fifo.write; // lock the data
      }
    }
  }
}
